# ROS2环境容器启动脚本记录

## 容器管理

- 将当前容器提交为镜像

假设你想要把你名为 ros2_humble_persistent 的容器保存为一个名为 ros2_humble_persistent_image:latest 的新镜像。

  第一步：找到容器的ID或名称（如果忘记了）
    打开一个 PowerShell 或 CMD 窗口，运行以下命令查看正在运行的容器：

  `docker ps`

  在输出的 NAMES 列找到你的容器名字，比如 `ros2_humble_persistent`。

  第二步：运行 docker commit 命令
  在同一个 PowerShell 或 CMD 窗口中，执行 commit 命令：

  `docker commit ros2_humble_persistent ros2_humble_persistent_image:latest`

  执行后，Docker会处理一段时间，然后返回新镜像的ID，表示提交成功。

  第三步：验证新镜像是否已创建
    运行以下命令查看本地的镜像列表：

  `docker images`

  你应该能在列表的顶部看到你刚刚创建的 `ros2_humble_persistent_image`，其标签为 `latest`。

现在，你就成功地将容器的当前状态“快照”成了一个可以随时用来创建新容器的镜像了。你之前的脚本就是自动为你完成了这整个流程。

## 版本：V6

核心功能列表：

  - 一键启动完整的开发环境:

      - 自动启动并等待 Docker Desktop 就绪，无需手动操作。

      - 自动启动 VcXsrv (X Server)，为在Windows上运行ROS 2的图形化界面（如RViz2, Gazebo）提供支持。

      - 自动打开 VSCode，方便你立即开始编码。

  - 通过镜像实现状态持久化 (核心功能):

      - 自动保存: 当你结束工作并从容器中 exit 时，脚本会自动将容器当前的所有状态（包括你新安装的软件、修改的系统配置等）提交（commit）为一个新的Docker镜像。

      - 自动恢复: 下次启动脚本时，它会自动从上次保存的镜像来创建新容器，完全恢复你之前的工作环境，实现无缝衔接。

      - 首次运行支持: 如果是第一次运行，脚本会智能地从官方的 osrf/ros:humble-desktop-full 基础镜像开始创建容器。

  - 干净的、临时的容器管理:

      - 每次启动时，容器都是一个全新的实例，确保了环境的一致性。

      - 每次退出后，该临时容器会被自动停止并删除，不会在你的系统里留下大量停止的旧容器，保持Docker环境的整洁。

      - 脚本还会自动清理因异常关闭而残留的旧容器。

  - 工作区文件持久化:

      - 通过Docker的卷挂载功能 (-v 参数)，将你的本地工作区目录（D:\BME2025\LearnROS\ros2_workspaces）映射到容器内部。这意味着你的代码和项目文件是直接保存在你的Windows电脑上的，即使没有镜像，你的代码也绝不会丢失。

  - 高度可配置和自动化:

      - 你可以在脚本顶部的“用户配置区域”轻松修改所有关键路径、容器名称和镜像名称，无需改动核心逻辑。

      - 脚本会自动为你创建初始的 .ros2_bashrc 配置文件，并预设了 ROS_DOMAIN_ID 等常用配置。

  - 优化的网络配置:

      - 脚本使用 --network host 模式启动容器，让容器直接使用你主机的网络。这极大地简化了与外部硬件（如你的UR3机械臂）的通信，避免了复杂的端口转发和防火墙问题。

  - 会话结束后的清理选项:

      - 在所有工作完成后，脚本会提供选项，让你决定是否要彻底关闭Docker Desktop和WSL，实现资源的完全释放。

```bash

@echo off
setlocal EnableDelayedExpansion
chcp 65001 >nul
title ROS 2 Humble 镜像持久化开发环境 V6
:: ============================================================================
::  ros2_env_v6.bat (改写版 V6)
::  自动化启动 ROS 2 Humble 镜像持久化 Docker 容器
::  功能：
::   - 每次退出时，将容器的改动保存为一个同名的新镜像。
::   - 每次启动时，从最新的镜像创建容器，实现状态继承。
::   - 容器本身是临时的，每次会话后都会被删除，保持环境干净。
::   - 自动注入主机 .ros2_bashrc 到容器。
:: ============================================================================

:: ---------------------------------------------------------------------------
:: (1) 用户配置区域
:: ---------------------------------------------------------------------------
set "ContainerName=ros2_humble_persistent"
set "ImageName=ros2_humble_persistent_image:latest"
set "HostWS=D:\BME2025\LearnROS\ros2_workspaces"
set "VcXsrvPath=C:\Users\99741\Desktop\ros2.xlaunch"
set "DockerPath=C:\Program Files\Docker\Docker\Docker Desktop.exe"
set "VSCodePath=C:\Users\99741\AppData\Local\Programs\Microsoft VS Code\Code.exe"

:: 主机侧 ROS2 个性配置文件（自动挂载并注入）
set "RosBashrcHost=%HostWS%\.ros2_bashrc"
set "RosBashrcContainer=/ros2_workspaces/.ros2_bashrc"

:: ---------------------------------------------------------------------------
:: (2) 启动依赖程序 (无变动)
:: ---------------------------------------------------------------------------
echo.
echo [Step 1/6] Starting background applications...
if not exist "%DockerPath%" (
    echo    - ERROR: Docker Desktop not found at "%DockerPath%". Check path.
    pause & exit /b
)
echo    - Starting Docker Desktop...
start "" "%DockerPath%"

if exist "%VcXsrvPath%" (
    echo    - Starting VcXsrv ...
    start "" "%VcXsrvPath%"
) else (
    echo    - WARNING: VcXsrv config not found. GUI may fail.
)

:: ---------------------------------------------------------------------------
:: (3) 等待 Docker 就绪 (无变动)
:: ---------------------------------------------------------------------------
echo.
echo [Step 2/6] Waiting for Docker daemon ...
:waitDocker
docker info >nul 2>&1
if !ERRORLEVEL! equ 0 goto dockerOK
echo|set /p=.
ping -n 3 127.0.0.1 >nul
goto waitDocker
:dockerOK

:: ---------------------------------------------------------------------------
:: (4) 检查/创建主机工作区 & 个性配置文件 (无变动)
:: ---------------------------------------------------------------------------
if not exist "%HostWS%" mkdir "%HostWS%"
if not exist "%RosBashrcHost%" (
    echo # ROS 2 Humble user customisations > "%RosBashrcHost%"
    echo source /opt/ros/humble/setup.bash >> "%RosBashrcHost%"
    echo # test if it works >> "%RosBashrcHost%"
    echo export ROS_DOMAIN_ID=42 >> "%RosBashrcHost%"
)

:: ---------------------------------------------------------------------------
:: (5) 容器与镜像生命周期管理 (核心改动 - 启动部分)
:: ---------------------------------------------------------------------------
echo.
echo [Step 3/6] Managing container and image lifecycle...

:: 如果上次异常退出导致旧容器残留，先强制删除
docker inspect %ContainerName% >nul 2>&1
if !ERRORLEVEL! equ 0 (
    echo   - Found and removing leftover container from previous session...
    docker rm -f %ContainerName% >nul
)

:: 检查持久化镜像是否存在
docker image inspect %ImageName% >nul 2>&1
if !ERRORLEVEL! equ 0 (
    echo   - Found persistent image '%ImageName%'. Starting container from it.
    set "ImageToUse=%ImageName%"
) else (
    echo   - Persistent image '%ImageName%' not found. This must be the first run.
    echo   - Creating new container from base image 'osrf/ros:humble-desktop-full'.
    echo   - (The image will be created on exit)
    set "ImageToUse=osrf/ros:humble-desktop-full"
)

:: 以后台模式(-d)创建并启动容器
echo   - Creating and starting new container '%ContainerName%'...
docker run -itd ^
  --name %ContainerName% ^
  --network host ^
  --privileged ^
  -e DISPLAY=172.27.128.1:0.0 ^
  -v "%HostWS%:/ros2_workspaces" ^
  %ImageToUse% >nul

:: 确认容器已成功启动
docker inspect %ContainerName% >nul 2>&1
if !ERRORLEVEL! neq 0 (
    echo   - ERROR: Failed to create or start the container. Aborting.
    pause & exit /b
) else (
    echo   - Container is running in the background.
)

:: ---------------------------------------------------------------------------
:: (6) 注入个性配置 (逻辑移动到下一步骤中)
:: ---------------------------------------------------------------------------

:: ---------------------------------------------------------------------------
:: (7) 启动 VSCode (无变动)
:: ---------------------------------------------------------------------------
echo.
echo [Step 4/6] Launching VSCode ...
start "" "%VSCodePath%" >NUL 2>&1

:: ---------------------------------------------------------------------------
:: (8) 进入容器交互 (无变动)
:: ---------------------------------------------------------------------------
echo.
echo [Step 5/6] Attaching to container (%ContainerName%) ...
echo   - Type 'exit' to leave and SAVE the container state to an image.
echo.
docker exec -it %ContainerName% bash

:: ---------------------------------------------------------------------------
:: (9) 退出后：提交、停止并移除容器 (核心改动 - 退出部分)
:: ---------------------------------------------------------------------------
echo.
echo [Step 6/6] Container session ended. Saving state...

echo   - Committing container '%ContainerName%' to image '%ImageName%'...
docker commit %ContainerName% %ImageName% >nul

echo   - Stopping container...
docker stop %ContainerName% >nul

echo   - Removing temporary container...
docker rm %ContainerName% >nul
echo   - Lifecycle complete. All changes saved in image '%ImageName%'.

:: ---------------------------------------------------------------------------
:: (10) 可选：关闭后台程序 (无变动)
:: ---------------------------------------------------------------------------
    echo    - Shutting down WSL and Docker ...
    wsl --shutdown
    taskkill /F /IM "Docker Desktop.exe" 2>nul
    taskkill /F /IM "com.docker.backend.exe" 2>nul
    taskkill /F /IM vcxsrv.exe 2>nul

echo.
echo ======================  All done. ======================

```